	;; найти количество комбинаций "000" в остатке от деления s1/s2 
.model small

.data

s1 dw 0001000011001111b
s2 dw 0000000001000010b
s3 db 00000111b 		;для сравнения

n db 0

.code
.486

mov ax,@data
mov ds,ax
mov ax,s1 ;делимое в ax
mov dx,0  ;обнуляем dx, чтобы было правильное(да хз) ax:dx для деления
mov bx,s2 ;делитель в bx
idiv bx   ;остаток в dx

mov cx,0  ;счетчик разрядов
mov ax,dx ;переносим остаток от деления в AX, допустим остаток будет = 0001100100000001
                        	;соответственно комбинаций 000 будет 6 

not ax 				;инвертируем, т.к. сравниваем с 111, получится 1110011011111110
				;(потому что так проще чем с 000)

jmp m1				;переходим на m1

m3:
	shr ax,1 ;сдвиг на 1 вправо
	inc cx   ;счетчик разрядов+1
	cmp cx,16;проверка конца
	jge m4   ;если конец идем на m4, если не конец продолжается ниже, где m1

m1:
	xor bh,bh;обнуляем (ну какая разница BH или BL....)
	mov bl,al;копируем al в bl (остаток от деления в AX, а в AL младший байт)
	and bl,s3;побитовое И, сравнивается с 00000111, если в bl например 00110111, то результат = 00000111
	cmp bl,s3;проверка на равенство с 7 (00000111)
	
	jne m3   ;если не равно идем на m3, если равно продолжается ниже

	inc n    ;совпадения+1 
	shr ax,1 ;сдвиг на 1 вправо 
	inc cx   ;счетчик разрядов+1 (чтобы не сдвигать бесконечно)
	cmp cx,16;проверка конца, обработаны ли все разряды 
	jl m1    ;если не конец идем на m1,если конец то выход из программы

m4:
	mov ah,4ch
	int 21h
end
